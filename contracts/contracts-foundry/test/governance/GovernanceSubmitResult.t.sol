// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {Test} from "forge-std/Test.sol";
import {GovernanceSetup} from "./GovernanceSetup.t.sol";
import {MockEnclave} from "./mocks/MockEnclave.t.sol";
import {MockTarget} from "./mocks/MockTarget.t.sol";
import {IGovernanceTypes} from "../../src/governance/interfaces/IGovernanceTypes.sol";
import {IGovernanceErrors} from "../../src/governance/interfaces/IGovernanceErrors.sol";

/// @notice Since votes in Governance are aggregated by Enclave, 
///         this test skips the voting process and only tests with results generated by MockEnclave.
contract GovernanceSubmitResultTest is GovernanceSetup {
    MockEnclave public mockEnclave;
    MockTarget public mockTarget;
    bytes32 public testProposalId;

    function setUp() public override {
        super.setUp();
        mockEnclave = new MockEnclave();
        mockTarget = new MockTarget();
        testProposalId = keccak256("test proposal");
    }

    // ========== Happy Path Test ==========
    
    function test_submitResult_Passed_ExecuteProposal() public {
        // Create a proposal that will pass
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 42);
        
        string memory title = "Test Proposal";
        string memory description = "A test proposal to set value to 42";
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: title,
                description: description
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create passing vote result (60% yes, 20% no, 10% abstain, 10% noWithVeto)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.6 * 1e18,     // 60%
            no: 0.2 * 1e18,      // 20%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.1 * 1e18 // 10%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Verify the proposal passed
        // Note: We can't directly access voteOutcome, but we can check if execution is possible
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal
        vm.prank(admin);
        governance.execute(proposalId);
        
        // Verify the execution worked
        assertEq(mockTarget.value(), 42, "Value should be set to 42");
        assertEq(mockTarget.lastCaller(), address(governance), "Last caller should be governance contract");
    }

    function test_submitResult_Passed_ExecuteETHTransfer() public {
        // Create a proposal to transfer ETH
        address recipient = makeAddr("recipient");
        uint256 transferAmount = 0.1 ether;
        
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = transferAmount;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.transferETH.selector, recipient);
        
        string memory title = "ETH Transfer Proposal";
        string memory description = "Transfer ETH to recipient";
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: transferAmount}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: title,
                description: description
            })
        );
        
        // Fund the governance contract
        vm.deal(address(governance), transferAmount);
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create passing vote result (70% yes, 15% no, 10% abstain, 5% noWithVeto)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.7 * 1e18,     // 70%
            no: 0.15 * 1e18,     // 15%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.05 * 1e18 // 5%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Record initial balances
        uint256 initialRecipientBalance = recipient.balance;
        uint256 initialGovernanceBalance = address(governance).balance;
        
        // Execute the proposal
        vm.prank(admin);
        governance.execute(proposalId);
        
        // Verify the ETH transfer worked
        assertEq(recipient.balance, initialRecipientBalance + transferAmount, "Recipient should receive ETH");
        assertEq(address(governance).balance, initialGovernanceBalance - transferAmount, "Governance should send ETH");
    }

    function test_submitResult_Passed_ExecuteMultipleTargets() public {
        // Create proposal with multiple targets (EOA and contract)
        address recipient1 = vm.addr(0x1234);
        address recipient2 = vm.addr(0x5678);
        vm.label(recipient1, "recipient1");
        vm.label(recipient2, "recipient2");

        vm.startPrank(proposer);
        vm.deal(proposer, 1 ether);

        address[] memory targets = new address[](3);
        uint256[] memory values = new uint256[](3);
        bytes[] memory calldatas = new bytes[](3);

        // Target 1: Contract call (setValue)
        targets[0] = address(mockTarget);
        values[0] = 0.1 ether;
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 42);

        // Target 2: EOA transfer
        targets[1] = recipient1;
        values[1] = 0.05 ether;
        calldatas[1] = "";

        // Target 3: Contract call (transferETH)
        targets[2] = address(mockTarget);
        values[2] = 0.05 ether;
        calldatas[2] = abi.encodeWithSelector(MockTarget.transferETH.selector, recipient2);

        IGovernanceTypes.ProposeInputParams memory proposeParams = IGovernanceTypes.ProposeInputParams({
            depositToken: address(depositToken),
            targets: targets,
            values: values,
            calldatas: calldatas,
            title: "Multiple Targets Proposal",
            description: "A proposal with multiple targets: contract call, EOA transfer, and contract ETH transfer"
        });

        bytes32 proposalId = governance.propose{value: 0.2 ether}(proposeParams);
        vm.stopPrank();

        // Give governance contract ETH for transfers
        vm.deal(address(governance), 0.2 ether);

        // Get proposal info
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);

        // Warp to after vote deadline
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);

        // Get result from MockEnclave (70% yes, 20% no, 10% abstain, 0% veto)
        IGovernanceTypes.SubmitResultInputParams memory resultParams = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            MockEnclave.VotePercentage({
                yes: 0.7 * 1e18,
                no: 0.2 * 1e18,
                abstain: 0.1 * 1e18,
                noWithVeto: 0
            }),
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );

        // Submit result
        vm.prank(admin);
        governance.submitResult(resultParams);

        // Warp to after proposal deadline
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);

        // Execute proposal
        vm.prank(admin);
        governance.execute(proposalId);

        // Verify results
        assertEq(mockTarget.value(), 42, "MockTarget value should be set to 42");
        assertEq(recipient1.balance, 0.05 ether, "recipient1 should receive 0.05 ETH");
        assertEq(recipient2.balance, 0.05 ether, "recipient2 should receive 0.05 ETH");
    }

    function test_submitResult_Passed_ExecuteRevertWhenInvalidCall() public {
        // Create a proposal that will revert during execution
        vm.startPrank(proposer);
        vm.deal(proposer, 1 ether);

        address[] memory targets = new address[](2);
        uint256[] memory values = new uint256[](2);
        bytes[] memory calldatas = new bytes[](2);

        // Target 1: Valid call (setValue)
        targets[0] = address(mockTarget);
        values[0] = 0.1 ether;
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 42);

        // Target 2: Invalid call (will revert) - call non-existent function
        targets[1] = address(mockTarget);
        values[1] = 0.1 ether;
        calldatas[1] = abi.encodeWithSelector(bytes4(keccak256("nonExistentFunction()"))); // This will definitely revert

        IGovernanceTypes.ProposeInputParams memory proposeParams = IGovernanceTypes.ProposeInputParams({
            depositToken: address(depositToken),
            targets: targets,
            values: values,
            calldatas: calldatas,
            title: "Revert Test Proposal",
            description: "A proposal that will revert during execution"
        });

        bytes32 proposalId = governance.propose{value: 0.2 ether}(proposeParams);
        vm.stopPrank();

        // Give governance contract ETH
        vm.deal(address(governance), 0.2 ether);

        // Get proposal info
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);

        // Warp to after vote deadline
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);

        // Get result from MockEnclave (60% yes, 30% no, 10% abstain, 0% veto)
        IGovernanceTypes.SubmitResultInputParams memory resultParams = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            MockEnclave.VotePercentage({
                yes: 0.6 * 1e18,
                no: 0.3 * 1e18,
                abstain: 0.1 * 1e18,
                noWithVeto: 0
            }),
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );

        // Submit result
        vm.prank(admin);
        governance.submitResult(resultParams);

        // Warp to after proposal deadline
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);

        // Execute proposal - this should revert due to the second call
        vm.prank(admin);
        vm.expectRevert();
        governance.execute(proposalId);

        // Verify that the first call was executed (if it got that far)
        // Note: In practice, the entire execution would revert, but we can check if the first call was attempted
    }

    function test_submitResult_Passed_ExecuteRevertWhenNoTargets() public {
        // Create proposal with no targets (only title and description)
        vm.startPrank(proposer);
        vm.deal(proposer, 1 ether);

        address[] memory targets = new address[](0);
        uint256[] memory values = new uint256[](0);
        bytes[] memory calldatas = new bytes[](0);

        IGovernanceTypes.ProposeInputParams memory proposeParams = IGovernanceTypes.ProposeInputParams({
            depositToken: address(depositToken),
            targets: targets,
            values: values,
            calldatas: calldatas,
            title: "No Targets Proposal",
            description: "A proposal with no targets, values, or calldatas - just title and description"
        });

        bytes32 proposalId = governance.propose{value: 0}(proposeParams);
        vm.stopPrank();

        // Get proposal info
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);

        // Warp to after vote deadline
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);

        // Get result from MockEnclave (80% yes, 10% no, 10% abstain, 0% veto)
        IGovernanceTypes.SubmitResultInputParams memory resultParams = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            MockEnclave.VotePercentage({
                yes: 0.8 * 1e18,
                no: 0.1 * 1e18,
                abstain: 0.1 * 1e18,
                noWithVeto: 0
            }),
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );

        // Submit result
        vm.prank(admin);
        governance.submitResult(resultParams);

        // Warp to after proposal deadline
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);

        // Execute proposal - this should fail because no targets means proposal is not in queue
        vm.prank(admin);
        vm.expectRevert();
        governance.execute(proposalId);

        // Verify that execution failed as expected
        // No targets means the proposal cannot be executed
    }

    // ========== _calcVoteResult Logic Tests ==========

    /// @notice Test when proposal passes with clear majority
    /// @dev VoteOutcome: PASSED
    ///      - yes (70%) > (no + noWithVeto) (25%) O
    ///      - yes (70%) > threshold (1% = 10%) O
    ///      - Result: Proposal passes and can be executed
    function test_submitResult_Passed_WhenClearMajority() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 100);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Clear Majority Proposal",
                description: "A proposal with clear majority support"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create passing vote result (70% yes, 20% no, 5% abstain, 5% noWithVeto)
        // yes (70) > (no + noWithVeto) (25) and yes (70) > threshold (1% = 10)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.7 * 1e18,     // 70%
            no: 0.2 * 1e18,      // 20%
            abstain: 0.05 * 1e18, // 5%
            noWithVeto: 0.05 * 1e18 // 5%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should succeed
        vm.prank(admin);
        governance.execute(proposalId);
        
        // Verify the execution worked
        assertEq(mockTarget.value(), 100, "Value should be set to 100");
    }

    /// @notice Test when proposal fails due to quorum not met
    /// @dev VoteOutcome: FAILED
    ///      - Total votes (3%) < quorum threshold (5%) X
    ///      - Result: Proposal fails due to insufficient participation
    function test_submitResult_Failed_WhenQuorumNotMet() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 200);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Low Quorum Proposal",
                description: "A proposal with insufficient quorum"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create failing vote result with low participation (3% total votes, below 5% quorum)
        // Total: 3% < 5% quorum threshold
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.02 * 1e18,    // 2%
            no: 0.005 * 1e18,    // 0.5%
            abstain: 0.003 * 1e18, // 0.3%
            noWithVeto: 0.002 * 1e18 // 0.2%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to quorum not met
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    /// @notice Test when proposal is vetoed
    /// @dev VoteOutcome: VETOED
    ///      - yes (20%) < (no + noWithVeto) (70%) O
    ///      - no (10%) < noWithVeto (60%) O
    ///      - noWithVeto (60%) > threshold (1% = 10%) O
    ///      - Result: Proposal is vetoed and cannot be executed
    function test_submitResult_Vetoed_WhenVetoThresholdExceeded() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 300);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Vetoed Proposal",
                description: "A proposal that gets vetoed"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create veto vote result (20% yes, 10% no, 10% abstain, 60% noWithVeto)
        // yes (20) < (no + noWithVeto) (70) && no (10) < noWithVeto (60) && noWithVeto (60) > threshold (1% = 10)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.2 * 1e18,     // 20%
            no: 0.1 * 1e18,      // 10%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.6 * 1e18 // 60%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to veto
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    /// @notice Test when proposal fails due to yes votes not exceeding opposition
    /// @dev VoteOutcome: FAILED
    ///      - yes (40%) = (no + noWithVeto) (40%) X
    ///      - Result: Proposal fails due to no clear majority
    function test_submitResult_Failed_WhenYesVotesEqualOpposition() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 400);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Tied Opposition Proposal",
                description: "A proposal where yes votes equal opposition"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create failing vote result (40% yes, 30% no, 10% abstain, 10% noWithVeto)
        // yes (40) = (no + noWithVeto) (40) - no clear majority
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.4 * 1e18,     // 40%
            no: 0.3 * 1e18,      // 30%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.1 * 1e18 // 10%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to no clear majority
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    /// @notice Test when proposal fails due to yes votes below threshold
    /// @dev VoteOutcome: FAILED
    ///      - yes (0.5%) > (no + noWithVeto) (0.3%) O
    ///      - yes (0.5%) < threshold (1% = 10%) X
    ///      - Result: Proposal fails due to insufficient yes votes
    function test_submitResult_Failed_WhenYesVotesBelowThreshold() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 500);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Low Yes Votes Proposal",
                description: "A proposal with yes votes below threshold"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create failing vote result (0.5% yes, 0.2% no, 0.1% abstain, 0.1% noWithVeto)
        // yes (0.5) > (no + noWithVeto) (0.3) but yes (0.5) < threshold (1% = 10)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.005 * 1e18,   // 0.5%
            no: 0.002 * 1e18,    // 0.2%
            abstain: 0.001 * 1e18, // 0.1%
            noWithVeto: 0.001 * 1e18 // 0.1%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to yes votes below threshold
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    /// @notice Test when proposal fails due to no votes exceeding veto votes
    /// @dev VoteOutcome: FAILED
    ///      - yes (20%) < (no + noWithVeto) (70%) O
    ///      - no (40%) > noWithVeto (30%) X (no veto condition)
    ///      - Result: Proposal fails due to no clear decision
    function test_submitResult_Failed_WhenNoVotesExceedVetoVotes() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 600);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "No Exceeds Veto Proposal",
                description: "A proposal where no votes exceed veto votes"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create failing vote result (20% yes, 40% no, 10% abstain, 30% noWithVeto)
        // yes (20) < (no + noWithVeto) (70) && no (40) > noWithVeto (30) - no veto condition met
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.2 * 1e18,     // 20%
            no: 0.4 * 1e18,      // 40%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.3 * 1e18 // 30%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to no clear decision
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    /// @notice Test when proposal fails due to veto votes below threshold
    /// @dev VoteOutcome: FAILED
    ///      - yes (20%) < (no + noWithVeto) (5.5%) O
    ///      - no (5%) < noWithVeto (0.5%) O
    ///      - noWithVeto (0.5%) < threshold (1% = 10%) X
    ///      - Result: Proposal fails due to insufficient veto votes
    function test_submitResult_Failed_WhenVetoVotesBelowThreshold() public {
        // Create a proposal
        address[] memory targets = new address[](1);
        targets[0] = address(mockTarget);
        
        uint256[] memory values = new uint256[](1);
        values[0] = 0.1 ether;
        
        bytes[] memory calldatas = new bytes[](1);
        calldatas[0] = abi.encodeWithSelector(MockTarget.setValue.selector, 700);
        
        // Propose the governance action
        vm.prank(proposer);
        vm.deal(proposer, 1 ether);
        bytes32 proposalId = governance.propose{value: 0.1 ether}(
            IGovernanceTypes.ProposeInputParams({
                depositToken: address(depositToken),
                targets: targets,
                values: values,
                calldatas: calldatas,
                title: "Low Veto Votes Proposal",
                description: "A proposal with veto votes below threshold"
            })
        );
        
        // Get proposal info for signing
        IGovernanceTypes.ProposalTimeInfo memory timeInfo = governance.getProposalTimeInfo(proposalId);
        bytes32 networkHash = governanceEnclave.getNetworkHash();
        bytes32 voteHash = governance.getVoteHash(proposalId);
        
        // Wait for vote deadline to pass
        vm.warp(timeInfo.voteDeadlineTimestamp + 1);
        
        // Create failing vote result (20% yes, 5% no, 10% abstain, 0.5% noWithVeto)
        // yes (20) < (no + noWithVeto) (5.5) && no (5) < noWithVeto (0.5) && noWithVeto (0.5) < threshold (1% = 10)
        MockEnclave.VotePercentage memory votePercentage = MockEnclave.VotePercentage({
            yes: 0.2 * 1e18,     // 20%
            no: 0.05 * 1e18,     // 5%
            abstain: 0.1 * 1e18, // 10%
            noWithVeto: 0.005 * 1e18 // 0.5%
        });
        
        // Get signed result from MockEnclave
        IGovernanceTypes.SubmitResultInputParams memory params = mockEnclave.getResult(
            proposalId,
            governance.getProposalImageId(proposalId),
            votePercentage,
            address(governance),
            timeInfo.proposedTimestamp,
            networkHash,
            governance.contractConfigHash(),
            voteHash
        );
        
        // Submit the result
        vm.prank(admin);
        governance.submitResult(params);
        
        // Wait for execution to be possible
        vm.warp(timeInfo.proposalDeadlineTimestamp + 1);
        
        // Execute the proposal - should fail due to veto votes below threshold
        vm.prank(admin);
        vm.expectRevert(IGovernanceErrors.Governance__ProposalNotInQueue.selector);
        governance.execute(proposalId);
        
        // Verify the execution failed
        assertEq(mockTarget.value(), 0, "Value should remain unchanged");
    }

    // ========== Vote Outcome and Execution State Getter Tests ==========
    
    function test_getVoteOutcome_Pending() public {
        bytes32 proposalId = _createSimpleProposal();
        IGovernanceTypes.VoteOutcome outcome = governance.getVoteOutcome(proposalId);
        assertEq(uint256(outcome), uint256(IGovernanceTypes.VoteOutcome.Pending), "Vote outcome should be Pending");
    }

    function test_getVoteOutcome_RevertsForNonExistentProposal() public {
        bytes32 nonExistentId = keccak256("non-existent");
        vm.expectRevert(abi.encodeWithSignature("Governance__ProposalDoesNotExist()"));
        governance.getVoteOutcome(nonExistentId);
    }

    function test_isProposalExecuted_ReturnsFalse() public {
        bytes32 proposalId = _createSimpleProposal();
        assertFalse(governance.isProposalExecuted(proposalId), "Proposal should not be executed");
    }

    function test_isProposalExecuted_ReturnsFalseForNonExistent() public view {
        bytes32 nonExistentId = keccak256("non-existent");
        // Should NOT revert, just return false
        assertFalse(governance.isProposalExecuted(nonExistentId), "Non-existent proposal should return false");
    }

    function test_isProposalExecuted_Integration() public {
        // Test that it returns false for different proposal states
        bytes32 proposalId = _createSimpleProposal();
        
        // Initially should be false
        assertFalse(governance.isProposalExecuted(proposalId), "Should be false initially");
        
        // After voting period starts, still false
        _warpToVotingPeriod(proposalId);
        assertFalse(governance.isProposalExecuted(proposalId), "Should be false during voting");
        
        // After voting period ends, still false
        _warpToResultPeriod(proposalId);
        assertFalse(governance.isProposalExecuted(proposalId), "Should be false after voting");
    }

    function test_getProposalState_AfterExecution() public {
        // Create a proposal that passes
        bytes32 proposalId = _createSimpleProposal();
        
        // Warp to voting period and vote
        _warpToVotingPeriod(proposalId);
        
        vm.prank(voter1);
        _vote(proposalId, hex"1234", address(0), 0);
        
        // Warp to result period
        _warpToResultPeriod(proposalId);
        
        // Check state before result submission
        (
            IGovernanceTypes.VoteOutcome voteOutcome,
            bool executed,
            bool inExecutionQueue,
            ,
        ) = governance.getProposalState(proposalId);
        
        // Before result submission, should still be Pending
        assertEq(uint256(voteOutcome), uint256(IGovernanceTypes.VoteOutcome.Pending), "Should be Pending before result");
        assertFalse(executed, "Should not be executed");
        assertFalse(inExecutionQueue, "Should not be in queue");
    }
}