use std::collections::HashSet;
use std::sync::atomic::{AtomicBool, AtomicU64};
use std::sync::{Arc, Mutex, RwLock};

use anyhow::{anyhow, Context, Result};
use axum::http::Uri;
use axum::routing::{get, post};
use axum::Router;
use clap::Parser;
use ethers::types::{H160, U256};
use ethers::utils::public_key_to_address;
use http_on_vsock_server::{VsockAddrParser, VsockServer};
use k256::ecdsa::SigningKey;
use serde_json::from_str;
use tokio::fs;

use serverless::cgroups::Cgroups;
use serverless::model::{AppState, ConfigManager};
use serverless::node_handler::{
    export_signed_registration_message, get_tee_details, index, inject_immutable_config,
    inject_mutable_config,
};
use tokio_vsock::VsockListener;

// EXECUTOR CONFIGURATION PARAMETERS
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Cli {
    /// vsock address to listen on <cid:port>
    #[clap(short, long, value_parser = VsockAddrParser{})]
    vsock_addr: (u32, u32),

    // Path to the configuration file
    #[clap(
        long,
        value_parser,
        default_value = "./oyster_serverless_executor_config.json"
    )]
    config_file: String,
}

#[tokio::main]
// Program to run the executor
async fn main() -> Result<()> {
    let args = Cli::parse();
    let config_manager = ConfigManager::new(&args.config_file);
    let mut config = config_manager.load_config().unwrap();

    // Initialize the 'cgroups' available inside the enclave to execute user code
    let cgroups = Cgroups::new().context("Failed to retrieve cgroups")?;
    if cgroups.free.is_empty() {
        return Err(anyhow!("No cgroups found, make sure you have generated cgroups on your system using the instructions in the readme"));
    }

    // Read the 'secp256k1' private and public key of the enclave instance generated by keygen
    let enclave_signer_key = SigningKey::from_slice(
        fs::read(config.enclave_signer_file)
            .await
            .context("Failed to read the enclave signer key")?
            .as_slice(),
    )
    .context("Invalid enclave signer key")?;

    // Validate the format of the http_rpc_url and web_socket_url
    let _ = config
        .http_rpc_url
        .parse::<Uri>()
        .context("Invalid http_rpc_url format")?;
    let _ = config
        .web_socket_url
        .parse::<Uri>()
        .context("Invalid web_socket_url format")?;
    if !config.web_socket_url.ends_with('/') {
        config.web_socket_url.push('/');
    }

    let enclave_address = public_key_to_address(&enclave_signer_key.verifying_key());

    // Initialize App data that will be shared across multiple threads and tasks
    let app_data = AppState {
        job_capacity: cgroups.free.len(),
        cgroups: Arc::new(Mutex::new(cgroups)),
        secret_store_config_port: config.secret_store_config_port,
        workerd_runtime_path: config.workerd_runtime_path,
        secret_store_path: config.secret_store_path,
        execution_buffer_time: config.execution_buffer_time,
        common_chain_id: config.common_chain_id,
        http_rpc_url: config.http_rpc_url,
        ws_rpc_url: Arc::new(RwLock::new(config.web_socket_url)),
        tee_manager_contract_addr: config.tee_manager_contract_addr,
        jobs_contract_addr: config.jobs_contract_addr,
        code_contract_addr: config.code_contract_addr,
        num_selected_executors: config.num_selected_executors,
        enclave_address,
        enclave_signer: enclave_signer_key,
        immutable_params_injected: Arc::new(Mutex::new(false)),
        mutable_params_injected: Arc::new(Mutex::new(false)),
        enclave_registered: Arc::new(AtomicBool::new(false)),
        events_listener_active: Arc::new(Mutex::new(false)),
        enclave_draining: Arc::new(AtomicBool::new(false)),
        enclave_owner: Arc::new(Mutex::new(H160::zero())),
        http_rpc_client: Arc::new(Mutex::new(None)),
        job_requests_running: Arc::new(Mutex::new(HashSet::new())),
        last_block_seen: Arc::new(AtomicU64::new(0)),
        nonce_to_send: Arc::new(Mutex::new(U256::from(0))),
        jobs_contract_abi: from_str(include_str!("../Jobs.json"))?,
        code_contract_abi: from_str(include_str!("../CodeContract.json"))?,
    };

    // Create App using Router
    let app = Router::new()
        .route("/", get(index))
        .route("/immutable-config", post(inject_immutable_config))
        .route("/mutable-config", post(inject_mutable_config))
        .route("/tee-details", get(get_tee_details))
        .route(
            "/signed-registration-message",
            get(export_signed_registration_message),
        )
        .with_state(app_data);

    println!("Node server started on port {:?}", args.vsock_addr);

    let server = axum::Server::builder(VsockServer {
        listener: VsockListener::bind(args.vsock_addr.0, args.vsock_addr.1)
            .context("failed to create vsock listener")?,
    })
    .serve(app.into_make_service());

    server.await.context("server exited with error")?;

    Ok(())
}
