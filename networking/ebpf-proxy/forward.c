#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <arpa/inet.h>
#include <net/if.h>

#include <bpf/bpf.h>
#include <linux/vm_sockets.h> // For VSOCK specifics
#include <sys/socket.h>       // For socket functions

#include <bpf/libbpf.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/ip.h>

// Generated by bpftool
#include "intercept.skel.h"

// Global flag to handle termination
static volatile bool exiting = false;

// --- Constants ---
// Max packet data size
#define MAX_PKT_SIZE 1500 // Typical MTU

// --- Data Structure for Perf Event ---
// Structure must match the one in the BPF program
struct pkt_event {
  __u32 pkt_len;               // Original packet length
  __u8 pkt_data[MAX_PKT_SIZE]; // Captured packet data
};

// Callback function for handling received packet data
void handle_event(void *ctx, int cpu, void *data, __u32 data_sz) {
  struct pkt_event *event = (struct pkt_event *)data;
  struct iphdr *ip;
  char src_ip_str[INET_ADDRSTRLEN];
  char dst_ip_str[INET_ADDRSTRLEN];

  ip = (struct iphdr *)
           event->pkt_data; // pkt_data starts directly with IP header

  // Check IP version (optional sanity check)
  if (ip->version != 4) {
    return;
  }

  inet_ntop(AF_INET, &ip->saddr, src_ip_str, sizeof(src_ip_str));
  inet_ntop(AF_INET, &ip->daddr, dst_ip_str, sizeof(dst_ip_str));

  // TODO: send to vsock
}

// Callback function for handling lost event notifications
void handle_lost_events(void *ctx, int cpu, __u64 lost_cnt) {}

// Signal handler for graceful shutdown
void sig_handler(int sig) { exiting = true; }

// Helper to attach clsact qdisc if not present
int ensure_clsact_qdisc(int ifindex) {
  struct bpf_tc_hook hook = {
      .sz = sizeof(hook),
      .ifindex = ifindex,
      .attach_point = BPF_TC_INGRESS,
  };
  int err;

  err = bpf_tc_hook_create(&hook);
  if (err && errno != EEXIST) {
    fprintf(stderr,
            "Failed to create TC hook/ensure clsact on ifindex %d: %s\n",
            ifindex, strerror(errno));
    return -1;
  }
  if (!err) {
    bpf_tc_hook_destroy(&hook);
  }
  printf("Ensured clsact qdisc exists on ifindex %d\n", ifindex);
  return 0;
}

int if_index_init(char const *ifname, int *ifindex) {
  // Get interface index
  *ifindex = if_nametoindex(ifname);
  if (!*ifindex) {
    perror("if_nametoindex failed");
    return 1;
  }

  return 0;
}

int vsock_addr_init(char const *vsock_target, struct sockaddr_vm *vsock_addr) {
  unsigned int vsock_cid;
  unsigned int vsock_port;

  // Parse VSOCK target string
  if (sscanf(vsock_target, "%u:%u", &vsock_cid, &vsock_port) != 2) {
    fprintf(stderr, "ERROR: Invalid VSOCK target format. Use <cid>:<port>\n");
    return 1;
  }

  vsock_addr->svm_family = AF_VSOCK;
  vsock_addr->svm_port = vsock_port;
  vsock_addr->svm_cid = vsock_cid;

  return 0;
}

int main(int argc, char **argv) {
  struct intercept_bpf *skel = NULL;
  struct perf_buffer *pb = NULL;
  int err = 0;
  int ifindex;
  struct bpf_tc_hook tc_hook = {};
  struct bpf_tc_opts tc_opts = {};
  struct sockaddr_vm vsock_addr = {0};

  if (argc != 3) {
    fprintf(stderr, "Usage: %s <interface_name> <vsock_cid>:<vsock_port>\n",
            argv[0]);
    return 1;
  }

  err = if_index_init(argv[1], &ifindex);
  if (err) {
    return err;
  }

  err = vsock_addr_init(argv[2], &vsock_addr);
  if (err) {
    return err;
  }

  signal(SIGINT, sig_handler);
  signal(SIGTERM, sig_handler);

  // --- VSOCK Setup ---
  vsock_fd = socket(AF_VSOCK, SOCK_STREAM, 0);
  if (vsock_fd < 0) {
    perror("ERROR: Failed to create VSOCK socket");
    goto cleanup; // Use goto for centralized cleanup
  }

  printf("Attempting to connect to vsock cid %u port %u...\n", vsock_cid,
         vsock_port);
  if (connect(vsock_fd, (struct sockaddr *)&vsock_addr, sizeof(vsock_addr)) <
      0) {
    perror("ERROR: Failed to connect VSOCK socket");
    err = -errno; // Store error code for return
    goto cleanup;
  }
  printf("Successfully connected to vsock endpoint.\n");
  // --- End VSOCK Setup ---

  skel = intercept_bpf__open();
  if (!skel) {
    fprintf(stderr, "ERROR: Failed to open BPF skeleton\n");
    return 1;
  }

  err = intercept_bpf__load(skel);
  if (err) {
    fprintf(stderr, "ERROR: Failed to load and verify BPF skeleton\n");
    goto cleanup;
  }

  err = ensure_clsact_qdisc(ifindex);
  if (err) {
    goto cleanup;
  }

  tc_hook.sz = sizeof(tc_hook);
  tc_hook.ifindex = ifindex;
  tc_hook.attach_point = BPF_TC_EGRESS;

  err = bpf_tc_hook_create(&tc_hook);
  if (err && errno != EEXIST) {
    fprintf(stderr, "ERROR: Failed to create TC hook: %s\n", strerror(errno));
    goto cleanup;
  }
  if (!err) {
    printf("Created TC hook for egress on ifindex %d\n", ifindex);
  } else {
    printf("TC hook for egress on ifindex %d already exists\n", ifindex);
    err = 0;
  }

  tc_opts.sz = sizeof(tc_opts);
  tc_opts.prog_fd = bpf_program__fd(skel->progs.capture_egress_packets);
  tc_opts.flags = BPF_TC_F_REPLACE;

  err = bpf_tc_attach(&tc_hook, &tc_opts);
  if (err) {
    fprintf(stderr, "ERROR: Failed to attach TC program: %s\n",
            strerror(errno));
    goto cleanup;
  }
  printf("Successfully attached TC program to %s (ifindex %d) egress\n", ifname,
         ifindex);

  pb = perf_buffer__new(bpf_map__fd(skel->maps.perf_output), 8, handle_event,
                        handle_lost_events, NULL, NULL);
  if (!pb) {
    err = -errno;
    fprintf(stderr, "ERROR: Failed to set up perf buffer: %s\n",
            strerror(errno));
    goto cleanup;
  }

  printf("Listening for egress IP packet events (<1500 bytes frame size) on "
         "%s... Press Ctrl+C to exit.\n",
         ifname);

  while (!exiting) {
    err = perf_buffer__poll(pb, 100);
    if (err < 0 && err != -EINTR) {
      fprintf(stderr, "ERROR: Polling perf buffer failed: %s\n",
              strerror(-err));
      goto cleanup;
    }
    err = 0;
  }

cleanup:
  printf("\nCleaning up...\n");

  if (tc_opts.prog_fd > 0) {
    tc_opts.flags = 0;
    tc_opts.prog_fd = 0;
    tc_opts.prog_id = 0;
    err = bpf_tc_detach(&tc_hook, &tc_opts);
    if (err) {
      fprintf(stderr, "WARN: Failed to detach TC program: %s\n",
              strerror(errno));
    } else {
      printf("Detached TC program from %s egress\n", ifname);
    }
  }

  if (pb) {
    perf_buffer__free(pb);
  }
  intercept_bpf__destroy(skel);

  if (vsock_fd >= 0) {
    printf("Closing VSOCK socket (fd %d)\n", vsock_fd);
    close(vsock_fd);
    vsock_fd = -1; // Mark as closed
  }

  printf(
      "Cleanup complete. You may need to manually remove the clsact qdisc:\n");
  printf("  sudo tc qdisc del dev %s clsact\n", ifname);

  return err ? 1 : 0;
}
