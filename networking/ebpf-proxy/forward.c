#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#include <arpa/inet.h>
#include <net/if.h>

#include <bpf/bpf.h>
#include <linux/vm_sockets.h> // For VSOCK specifics
#include <sys/socket.h>       // For socket functions

#include <bpf/libbpf.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/ip.h>

// Generated by bpftool
#include "intercept.skel.h"

// Global flag to handle termination
static volatile bool exiting = false;
// Global vsock fd
static volatile int vsock_fd = -1;
// Global vsock err flag
static volatile bool vsock_err = false;

// --- Constants ---
// Max packet data size
#define MAX_PKT_SIZE 1500 // Typical MTU

// --- Data Structure for Perf Event ---
// Structure must match the one in the BPF program
struct pkt_event {
  __u32 pkt_len;               // Original packet length
  __u8 pkt_data[MAX_PKT_SIZE]; // Captured packet data
};

// Callback function for handling received packet data
void handle_event(void *ctx, int cpu, void *data, __u32 data_sz) {
  struct pkt_event *event = (struct pkt_event *)data;

  if (vsock_fd < 0) {
    // should never happen
    return;
  }

  int total_sent = 0;
  while (total_sent < event->pkt_len) {
    int res = send(vsock_fd, event->pkt_data + total_sent,
                   event->pkt_len - total_sent, 0);
    if (res < 0) {
      vsock_err = true;
      return;
    }

    total_sent += res;
  }
}

// Callback function for handling lost event notifications
void handle_lost_events(void *ctx, int cpu, __u64 lost_cnt) {}

void bpf_teardown(struct intercept_bpf *skel, struct bpf_tc_hook *tc_hook,
                  bool existing_hook, struct bpf_tc_opts *tc_opts,
                  struct perf_buffer *pb) {
  perf_buffer__free(pb);
  bpf_tc_detach(tc_hook, tc_opts);
  if (!existing_hook)
    bpf_tc_hook_destroy(tc_hook);
  intercept_bpf__destroy(skel);
}

void vsock_teardown() {
  close(vsock_fd);
  vsock_fd = -1;
}

// Helper to attach clsact qdisc if not present
int ensure_clsact_qdisc(int ifindex) {
  struct bpf_tc_hook hook = {
      .sz = sizeof(hook),
      .ifindex = ifindex,
      .attach_point = BPF_TC_INGRESS,
  };
  int err;

  err = bpf_tc_hook_create(&hook);
  if (err && errno != EEXIST) {
    fprintf(stderr,
            "Failed to create TC hook/ensure clsact on ifindex %d: %s\n",
            ifindex, strerror(errno));
    return -1;
  }
  if (!err) {
    bpf_tc_hook_destroy(&hook);
  }
  printf("Ensured clsact qdisc exists on ifindex %d\n", ifindex);
  return 0;
}

void sleep_100ms(int n) {
  // sleep in multiples of 100ms to handle signals
  for (int i = 0; i < n && !exiting; i++) {
    usleep(100000);
  }
}

int vsock_connect(struct sockaddr_vm const *vsock_addr) {
  while (!exiting) {
    vsock_fd = socket(AF_VSOCK, SOCK_STREAM, 0);
    if (vsock_fd < 0) {
      perror("ERROR: Failed to create VSOCK socket");
      goto vsock_connect_socket_cleanup;
    }

    printf("Attempting to connect to vsock cid %u port %u...\n",
           vsock_addr->svm_cid, vsock_addr->svm_port);
    int err = connect(vsock_fd, (struct sockaddr const *)vsock_addr,
                      sizeof(*vsock_addr));
    if (err < 0) {
      perror("ERROR: Failed to connect VSOCK socket");
      goto vsock_connect_connect_cleanup;
    }

    printf("Successfully connected to vsock endpoint.\n");
    return 0;

  vsock_connect_connect_cleanup:
    close(vsock_fd);
    vsock_fd = -1;
  vsock_connect_socket_cleanup:
    sleep_100ms(10);
  }

  // should only get here on exit signals
  return 2;
}

int bpf_init(int ifindex, struct intercept_bpf *skel,
             struct bpf_tc_hook *tc_hook, bool *existing_hook,
             struct bpf_tc_opts *tc_opts, struct perf_buffer *pb) {
  while (!exiting) {
    *existing_hook = false;
    int err = 0;

    skel = intercept_bpf__open();
    if (!skel) {
      fprintf(stderr, "ERROR: Failed to open BPF skeleton\n");
      goto bpf_init_open_cleanup;
    }

    err = intercept_bpf__load(skel);
    if (err) {
      fprintf(stderr, "ERROR: Failed to load and verify BPF skeleton\n");
      goto bpf_init_load_cleanup;
    }

    err = ensure_clsact_qdisc(ifindex);
    if (err) {
      goto bpf_init_load_cleanup;
    }

    tc_hook->sz = sizeof(*tc_hook);
    tc_hook->ifindex = ifindex;
    tc_hook->attach_point = BPF_TC_EGRESS;

    err = bpf_tc_hook_create(tc_hook);
    if (err && errno != EEXIST) {
      fprintf(stderr, "ERROR: Failed to create TC hook: %s\n", strerror(errno));
      goto bpf_init_load_cleanup;
    }
    if (!err) {
      printf("Created TC hook for egress on ifindex %d\n", ifindex);
    } else {
      printf("TC hook for egress on ifindex %d already exists\n", ifindex);
      *existing_hook = true;
    }

    tc_opts->sz = sizeof(*tc_opts);
    tc_opts->prog_fd = bpf_program__fd(skel->progs.capture_egress_packets);
    tc_opts->flags = BPF_TC_F_REPLACE;

    err = bpf_tc_attach(tc_hook, tc_opts);
    if (err) {
      fprintf(stderr, "ERROR: Failed to attach TC program: %s\n",
              strerror(errno));
      goto bpf_init_attach_cleanup;
    }
    printf("Successfully attached TC program to %d egress\n", ifindex);

    pb = perf_buffer__new(bpf_map__fd(skel->maps.perf_output), 8, handle_event,
                          handle_lost_events, NULL, NULL);
    if (!pb) {
      fprintf(stderr, "ERROR: Failed to set up perf buffer: %s\n",
              strerror(errno));
      goto bpf_init_pb_cleanup;
    }

    printf("Listening for egress IP packet events on %d\n", ifindex);
    return 0;

  bpf_init_pb_cleanup:
    bpf_tc_detach(tc_hook, tc_opts);
  bpf_init_attach_cleanup:
    if (!*existing_hook)
      bpf_tc_hook_destroy(tc_hook);
  bpf_init_load_cleanup:
    intercept_bpf__destroy(skel);
  bpf_init_open_cleanup:
    sleep_100ms(10);
  }

  // should only get here on exit signals
  return 1;
}

// Signal handler for graceful shutdown
void sig_handler(int sig) { exiting = true; }

int if_index_init(char const *ifname, int *ifindex) {
  // Get interface index
  *ifindex = if_nametoindex(ifname);
  if (!*ifindex) {
    perror("if_nametoindex failed");
    return 1;
  }

  return 0;
}

int vsock_addr_init(char const *vsock_target, struct sockaddr_vm *vsock_addr) {
  unsigned int vsock_cid;
  unsigned int vsock_port;

  // Parse VSOCK target string
  if (sscanf(vsock_target, "%u:%u", &vsock_cid, &vsock_port) != 2) {
    fprintf(stderr, "ERROR: Invalid VSOCK target format. Use <cid>:<port>\n");
    return 1;
  }

  vsock_addr->svm_family = AF_VSOCK;
  vsock_addr->svm_port = vsock_port;
  vsock_addr->svm_cid = vsock_cid;

  return 0;
}

int main(int argc, char **argv) {
  int err = 0;
  int ifindex;
  struct sockaddr_vm vsock_addr = {0};
  struct intercept_bpf *skel = NULL;
  struct bpf_tc_hook tc_hook = {};
  bool existing_hook = false;
  struct bpf_tc_opts tc_opts = {};
  struct perf_buffer *pb = NULL;

  if (argc != 3) {
    fprintf(stderr, "Usage: %s <interface_name> <vsock_cid>:<vsock_port>\n",
            argv[0]);
    return 1;
  }

  err = if_index_init(argv[1], &ifindex);
  if (err) {
    return err;
  }

  err = vsock_addr_init(argv[2], &vsock_addr);
  if (err) {
    return err;
  }

  signal(SIGINT, sig_handler);
  signal(SIGTERM, sig_handler);

  err = bpf_init(ifindex, skel, &tc_hook, &existing_hook, &tc_opts, pb);
  if (err) {
    // should only be happening on exit signals
    return err;
  }

  err = vsock_connect(&vsock_addr);
  if (err) {
    // should only be happening on exit signals
    bpf_teardown(skel, &tc_hook, existing_hook, &tc_opts, pb);
    return err;
  }

  while (!exiting) {
    err = perf_buffer__poll(pb, 100);
    if (err < 0 && err != -EINTR) {
      goto main_bpf_error;
    }
    if (vsock_err) {
      vsock_err = false;
      goto main_vsock_error;
    }
    continue;
  main_bpf_error:
    bpf_teardown(skel, &tc_hook, existing_hook, &tc_opts, pb);
    sleep_100ms(10);
    err = bpf_init(ifindex, skel, &tc_hook, &existing_hook, &tc_opts, pb);
    if (err) {
      // should only be happening on exit signals
      vsock_teardown();
      return err;
    }
    continue;
  main_vsock_error:
    vsock_teardown();
    sleep_100ms(10);
    err = vsock_connect(&vsock_addr);
    if (err) {
      // should only be happening on exit signals
      bpf_teardown(skel, &tc_hook, existing_hook, &tc_opts, pb);
      return err;
    }
    continue;
  }

  return 0;
}
